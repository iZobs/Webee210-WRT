From 106260c0b78ec3e7e533665c791e9858bc74acc3 Mon Sep 17 00:00:00 2001
From: izobs <ivincentlin@gmail.com>
Date: Tue, 5 Aug 2014 11:39:13 +0800
Subject: [PATCH 1/2] 0002-fix-s3c-nand-driver

---
 arch/arm/plat-samsung/include/plat/nand.h |    6 +
 drivers/mtd/nand/Kconfig                  |   29 +
 drivers/mtd/nand/Makefile                 |    1 +
 drivers/mtd/nand/s3c_nand.c               | 1346 +++--------------------------
 4 files changed, 150 insertions(+), 1232 deletions(-)

diff --git a/arch/arm/plat-samsung/include/plat/nand.h b/arch/arm/plat-samsung/include/plat/nand.h
index b64115f..d626d17 100644
--- a/arch/arm/plat-samsung/include/plat/nand.h
+++ b/arch/arm/plat-samsung/include/plat/nand.h
@@ -65,3 +65,9 @@ struct s3c2410_platform_nand {
  * it with the s3c_device_nand. This allows @nand to be __initdata.
 */
 extern void s3c_nand_set_platdata(struct s3c2410_platform_nand *nand);
+
+struct s3c_nand_mtd_info {
+	uint chip_nr;
+	uint mtd_part_nr;
+	struct mtd_partition *partition;
+};
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index ffc3720..98c259c 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -234,6 +234,35 @@ config MTD_NAND_S3C2410_CLKSTOP
 	  when the is NAND chip selected or released, but will save
 	  approximately 5mA of power when there is nothing happening.
 
+config MTD_NAND_S3C
+    tristate "NAND Flash support for S3C SoC"
+        depends on MTD_NAND && (ARCH_S5PC1XX || ARCH_S5PC11X || ARCH_S5PV2XX || ARCH_S5PV210)
+    help
+      This enables the NAND flash controller on the S3C.
+
+      No board specfic support is done by this driver, each board
+      must advertise a platform_device for the driver to attach.
+
+config MTD_NAND_S3C_DEBUG
+    bool "S3C NAND driver debug"
+    depends on MTD_NAND_S3C
+    help
+      Enable debugging of the S3C NAND driver
+
+config MTD_NAND_S3C_HWECC
+    bool "S3C NAND Hardware ECC"
+    depends on MTD_NAND_S3C
+    help
+      Enable the use of the S3C's internal ECC generator when
+      using NAND. Early versions of the chip have had problems with
+      incorrect ECC generation, and if using these, the default of
+      software ECC is preferable.
+
+      If you lay down a device with the hardware ECC, then you will
+      currently not be able to switch to software, as there is no
+      implementation for ECC method used by the S3C
+    
+
 config MTD_NAND_BCM_UMI
 	tristate "NAND Flash support for BCM Reference Boards"
 	depends on ARCH_BCMRING && MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index e8ab884..c31aec4 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
 obj-$(CONFIG_MTD_NAND_BF5XX)		+= bf5xx_nand.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
 obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
+obj-$(CONFIG_MTD_NAND_S3C)		+= s3c_nand.o
 obj-$(CONFIG_MTD_NAND_DAVINCI)		+= davinci_nand.o
 obj-$(CONFIG_MTD_NAND_DISKONCHIP)	+= diskonchip.o
 obj-$(CONFIG_MTD_NAND_H1900)		+= h1910.o
diff --git a/drivers/mtd/nand/s3c_nand.c b/drivers/mtd/nand/s3c_nand.c
index 3160154..fbd53f1 100644
--- a/drivers/mtd/nand/s3c_nand.c
+++ b/drivers/mtd/nand/s3c_nand.c
@@ -1,15 +1,4 @@
-/* linux/drivers/mtd/nand/s3c_nand.c
- *
- * Copyright (c) 2009 Samsung Electronics Co., Ltd.
- *		http://www.samsung.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-*/
-
 #include <linux/module.h>
-#include <linux/delay.h>
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -18,1275 +7,168 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/err.h>
-#include <linux/clk.h>
-#include <linux/jiffies.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/nand_ecc.h>
 #include <linux/mtd/partitions.h>
 
+#include <asm/io.h>
+
 #include <plat/regs-nand.h>
 #include <plat/nand.h>
+#include "../mtdcore.h"
 
-#ifdef CONFIG_MTD_CMDLINE_PARTS
-static const char *part_probes[] = { "cmdlinepart", NULL };
-#endif
+static unsigned long *clk_gate_ip1;
+static unsigned long *clk_gate_block;
+static unsigned long *mp0_3con;
 
-#if defined(CONFIG_ARCH_S5PV210)
-struct mtd_partition s3c_partition_info[] = {
-	{
-		.name		= "misc",
-		.offset		= (768*SZ_1K),          /* for bootloader */
-		.size		= (256*SZ_1K),
-		.mask_flags	= MTD_CAP_NANDFLASH,
+static struct mtd_partition webee_nand_part[] = {
+	[0] = {
+		.name	= "webee_uboot",
+		.size	= SZ_1M,
+		.offset	= 0,
 	},
-	{
-		.name		= "recovery",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= (5*SZ_1M),
+	[1] = {
+		.name	= "webee_kernel",
+		.size	= 5*SZ_1M,
+		.offset	= MTDPART_OFS_APPEND,
 	},
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= (5*SZ_1M),
+	[2] = {
+		.name	= "webee_rootfs",
+		.size	= MTDPART_SIZ_FULL,
+		.offset	= MTDPART_OFS_APPEND,
 	},
-	{
-		.name		= "ramdisk",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= (3*SZ_1M),
-	},
-#ifdef CONFIG_MACH_MINI210
-	{
-		.name		= "system",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-	}
-#else
-	{
-		.name		= "system",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= (110*SZ_1M),
-	},
-	{
-		.name		= "cache",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= (80*SZ_1M),
-	},
-	{
-		.name		= "userdata",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-	}
-#endif
 };
 
-struct s3c_nand_mtd_info s3c_nand_mtd_part_info = {
-	.chip_nr = 1,
-	.mtd_part_nr = ARRAY_SIZE(s3c_partition_info),
-	.partition = s3c_partition_info,
+struct nand_regs {
+	unsigned long nfconf;
+	unsigned long nfcont;
+	unsigned long nfcmmd;
+	unsigned long nfaddr;
+	unsigned long nfdata;
+	unsigned long nfmeccd0;
+	unsigned long nfmeccd1;
+	unsigned long nfseccd;
+	unsigned long nfsblk;
+	unsigned long nfeblk;
+	unsigned long nfstat;
+	unsigned long nfeccerr0;
+	unsigned long nfeccerr1;
 };
-#endif
-
-enum s3c_cpu_type {
-	TYPE_S3C2450,	/* including s3c2416 */
-	TYPE_S3C6400,
-	TYPE_S3C6410,	/* including s3c6430/31 */
-	TYPE_S5P6440,
-	TYPE_S5PC100,
-	TYPE_S5PC110,
-	TYPE_S5PV210,
-};
-
-struct s3c_nand_info {
-	/* mtd info */
-	struct nand_hw_control		controller;
-	struct s3c_nand_mtd_info	*mtds;
-	struct s3c2410_platform_nand	*platform;
-
-	/* device info */
-	struct device			*device;
-	struct resource			*area;
-	struct clk			*clk;
-	void __iomem			*regs;
-	void __iomem			*sel_reg;
-	int				sel_bit;
-	int				mtd_count;
-
-	enum s3c_cpu_type		cpu_type;
-};
-static struct s3c_nand_info s3c_nand;
-
-static struct mtd_info *s3c_mtd;
-
-/* Nand flash definition values */
-#define S3C_NAND_TYPE_UNKNOWN	0x0
-#define S3C_NAND_TYPE_SLC	0x1
-#define S3C_NAND_TYPE_MLC	0x2
-
-/* when Hz=200, jiffies interval 1/200=5mS,
- * waiting for 80mS 80/5 = 16 */
-#define S3C_NAND_WAIT_TIME_MS	(80)
-#define S3C_NAND_WAIT_INTERVAL	(S3C_NAND_WAIT_TIME_MS * HZ / 1000)
-
-/* Nand flash global values */
-int cur_ecc_mode;
-int nand_type = S3C_NAND_TYPE_UNKNOWN;
-
-#if defined(CONFIG_MTD_NAND_S3C_HWECC)
-/* Nand flash oob definition for SLC 512b page size */
-static struct nand_ecclayout s3c_nand_oob_16 = {
-	.eccbytes = 4,
-	.eccpos = {
-		1, 2, 3, 4
-	},
-	.oobfree = {
-		{
-		.offset = 6,
-		.length = 10
-		}
-	}
-};
-
-/* Nand flash oob definition for SLC 2k page size */
-static struct nand_ecclayout s3c_nand_oob_64 = {
-	.eccbytes = 16,
-	.eccpos = {
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55
-	},
-	.oobfree = {
-		{
-		.offset = 2,
-		.length = 38
-		}
-	}
-};
-
-/* Nand flash oob definition for MLC 2k page size */
-static struct nand_ecclayout s3c_nand_oob_mlc_64 = {
-	.eccbytes = 32,
-	.eccpos = {
-		32, 33, 34, 35, 36, 37, 38, 39,
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55,
-		56, 57, 58, 59, 60, 61, 62, 63
-	},
-	.oobfree = {
-		{
-		.offset = 2,
-		.length = 28
-		}
-	}
-};
-
-/* Nand flash oob definition for 4Kb page size with 8_bit ECC */
-static struct nand_ecclayout s3c_nand_oob_128 = {
-	.eccbytes = 104,
-	.eccpos = {
-		24, 25, 26, 27, 28, 29, 30, 31,
-		32, 33, 34, 35, 36, 37, 38, 39,
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55,
-		56, 57, 58, 59, 60, 61, 62, 63,
-		64, 65, 66, 67, 68, 69, 70, 71,
-		72, 73, 74, 75, 76, 77, 78, 79,
-		80, 81, 82, 83, 84, 85, 86, 87,
-		88, 89, 90, 91, 92, 93, 94, 95,
-		96, 97, 98, 99, 100, 101, 102, 103,
-		104, 105, 106, 107, 108, 109, 110, 111,
-		112, 113, 114, 115, 116, 117, 118, 119,
-		120, 121, 122, 123, 124, 125, 126, 127},
-	.oobfree = {
-		{
-		.offset = 2,
-		.length = 22
-		}
-	}
-};
-#endif
-
-#if defined(CONFIG_MTD_NAND_S3C_DEBUG)
-/*
- * Function to print out oob buffer for debugging
- */
-void print_oob(const char *header, struct mtd_info *mtd)
-{
-	int i;
-	struct nand_chip *chip = mtd->priv;
-
-	printk(KERN_INFO "%s:\t", header);
-
-	for (i = 0; i < 64; i++)
-		printk(KERN_INFO "%02x ", chip->oob_poi[i]);
-
-	printk(KERN_INFO "\n");
-}
-EXPORT_SYMBOL(print_oob);
-#endif
-
-/*
- * Configure the PAGE SIZE for different nand flash
- */
-static void s3c_nand_init_later(struct mtd_info *mtd)
-{
-	void __iomem *regs = s3c_nand.regs;
-	u_long nfconf;
-
-	if (s3c_nand.cpu_type != TYPE_S5PV210)
-		return;
-
-	nfconf = readl(regs + S3C_NFCONF);
-
-	if (nand_type == S3C_NAND_TYPE_SLC) {
-		if (mtd->writesize == 512) {
-			nfconf |= S3C_NFCONF_PAGESIZE;
-		} else {
-			nfconf &= ~S3C_NFCONF_PAGESIZE;
-		}
-	} else {
-		if (mtd->writesize == 2048) {
-			nfconf |= S3C_NFCONF_PAGESIZE;
-		} else {
-			nfconf &= ~S3C_NFCONF_PAGESIZE;
-		}
-	}
-
-	writel(nfconf, regs + S3C_NFCONF);
-}
-
-/*
- * Hardware specific access to control-lines function
- */
-static void s3c_nand_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)
-{
-	unsigned int cur;
-	void __iomem *regs = s3c_nand.regs;
-
-	if (ctrl & NAND_CTRL_CHANGE) {
-		if (ctrl & NAND_NCE) {
-			if (dat != NAND_CMD_NONE) {
-				cur = readl(regs + S3C_NFCONT);
-				cur &= ~S3C_NFCONT_nFCE0;
-				writel(cur, regs + S3C_NFCONT);
-			}
-		} else {
-			cur = readl(regs + S3C_NFCONT);
-			cur |= S3C_NFCONT_nFCE0;
-			writel(cur, regs + S3C_NFCONT);
-		}
-	}
-
-	if (dat != NAND_CMD_NONE) {
-		if (ctrl & NAND_CLE)
-			writeb(dat, regs + S3C_NFCMMD);
-		else if (ctrl & NAND_ALE)
-			writeb(dat, regs + S3C_NFADDR);
-	}
-}
-
-/*
- * Function for checking device ready pin
- */
-static int s3c_nand_device_ready(struct mtd_info *mtd)
-{
-	void __iomem *regs = s3c_nand.regs;
-
-	/* it's to check the RnB nand signal bit and
-	 * return to device ready condition in nand_base.c
-	 */
-	return readl(regs + S3C_NFSTAT) & S3C_NFSTAT_READY;
-}
-
-/*
- * We don't use a bad block table
- */
-static int s3c_nand_scan_bbt(struct mtd_info *mtdinfo)
-{
-	return 0;
-}
-
-#if defined(CONFIG_MTD_NAND_S3C_HWECC)
-
-/*
- * Function for checking ECCEncDone in NFSTAT
- */
-static void s3c_nand_wait_enc(void)
-{
-	void __iomem *regs = s3c_nand.regs;
-	unsigned long timeo = jiffies;
-
-	timeo += S3C_NAND_WAIT_INTERVAL;
-
-	/* Apply this short delay always to ensure that we do wait tWB in
-	 * any case on any machine. */
-	while (time_before(jiffies, timeo)) {
-		if (readl(regs + S3C_NFSTAT) & S3C_NFSTAT_ECCENCDONE)
-			break;
-		cond_resched();
-	}
-}
-
-/*
- * Function for checking ECCDecDone in NFSTAT
- */
-static void s3c_nand_wait_dec(void)
-{
-	void __iomem *regs = s3c_nand.regs;
-	unsigned long timeo = jiffies;
-
-	timeo += S3C_NAND_WAIT_INTERVAL;
 
-	/* Apply this short delay always to ensure that we do wait tWB in
-	 * any case on any machine. */
-	while (time_before(jiffies, timeo)) {
-		if (readl(regs + S3C_NFSTAT) & S3C_NFSTAT_ECCDECDONE)
-			break;
-		cond_resched();
-	}
-}
+static struct nand_regs *nand_regs;
+static struct nand_chip *webee_nand_chip;
+static struct mtd_info *webee_nand_mtd;
 
-/*
- * Function for checking ECC Busy
- */
-static void s3c_nand_wait_ecc_busy(void)
+static void webee_nand_select_chip(struct mtd_info *mtd, int chipnr)
 {
-	void __iomem *regs = s3c_nand.regs;
-	unsigned long timeo = jiffies;
-
-	timeo += S3C_NAND_WAIT_INTERVAL;
-
-	/* Apply this short delay always to ensure that we do wait tWB in
-	 * any case on any machine. */
-	while (time_before(jiffies, timeo)) {
-		if (!(readl(regs + S3C_NFMECCERR0) & S3C_NFECCERR0_ECCBUSY))
-			break;
-		cond_resched();
-	}
-}
-
-/*
- * This function is called before encoding ecc codes to ready ecc engine.
- */
-static void s3c_nand_enable_hwecc(struct mtd_info *mtd, int mode)
-{
-	u_long nfcont;
-	u_long nfconf;
-	void __iomem *regs = s3c_nand.regs;
-
-	cur_ecc_mode = mode;
-
-	nfconf = readl(regs + S3C_NFCONF);
-
-	if (s3c_nand.cpu_type == TYPE_S3C6400) {
-		if (nand_type == S3C_NAND_TYPE_SLC)
-			nfconf &= ~S3C_NFCONF_ECC_MLC;	/* SLC */
-		else
-			nfconf |= S3C_NFCONF_ECC_MLC;	/* MLC */
-	} else {
-		nfconf &= ~(0x3 << 23);
-
-		if (nand_type == S3C_NAND_TYPE_SLC)
-			nfconf |= S3C_NFCONF_ECC_1BIT;
-		else
-			nfconf |= S3C_NFCONF_ECC_4BIT;
-	}
-
-	writel(nfconf, regs + S3C_NFCONF);
-
-	/* Init main ECC & unlock */
-	nfcont = readl(regs + S3C_NFCONT);
-	nfcont |= S3C_NFCONT_INITMECC;
-	nfcont &= ~S3C_NFCONT_MECCLOCK;
-
-	if (nand_type == S3C_NAND_TYPE_MLC) {
-		if (mode == NAND_ECC_WRITE)
-			nfcont |= S3C_NFCONT_ECC_ENC;
-		else if (mode == NAND_ECC_READ)
-			nfcont &= ~S3C_NFCONT_ECC_ENC;
-	}
-
-	writel(nfcont, regs + S3C_NFCONT);
-}
-
-/*
- * This function is called immediately after encoding ecc codes.
- * This function returns encoded ecc codes.
- */
-static int s3c_nand_calculate_ecc(struct mtd_info *mtd,
-		const u_char *dat, u_char *ecc_code)
-{
-	u_long nfcont, nfmecc0, nfmecc1;
-	void __iomem *regs = s3c_nand.regs;
-
-	/* Lock */
-	nfcont = readl(regs + S3C_NFCONT);
-	nfcont |= S3C_NFCONT_MECCLOCK;
-	writel(nfcont, regs + S3C_NFCONT);
-
-	if (nand_type == S3C_NAND_TYPE_SLC) {
-		nfmecc0 = readl(regs + S3C_NFMECC0);
-
-		ecc_code[0] = nfmecc0 & 0xff;
-		ecc_code[1] = (nfmecc0 >> 8) & 0xff;
-		ecc_code[2] = (nfmecc0 >> 16) & 0xff;
-		ecc_code[3] = (nfmecc0 >> 24) & 0xff;
-	} else {
-		if (cur_ecc_mode == NAND_ECC_READ)
-			s3c_nand_wait_dec();
-		else {
-			s3c_nand_wait_enc();
-
-			nfmecc0 = readl(regs + S3C_NFMECC0);
-			nfmecc1 = readl(regs + S3C_NFMECC1);
-
-			ecc_code[0] = nfmecc0 & 0xff;
-			ecc_code[1] = (nfmecc0 >> 8) & 0xff;
-			ecc_code[2] = (nfmecc0 >> 16) & 0xff;
-			ecc_code[3] = (nfmecc0 >> 24) & 0xff;
-			ecc_code[4] = nfmecc1 & 0xff;
-			ecc_code[5] = (nfmecc1 >> 8) & 0xff;
-			ecc_code[6] = (nfmecc1 >> 16) & 0xff;
-			ecc_code[7] = (nfmecc1 >> 24) & 0xff;
-		}
-	}
-
-	return 0;
-}
-
-/*
- * This function determines whether read data is good or not.
- * If SLC, must write ecc codes to controller before reading status bit.
- * If MLC, status bit is already set, so only reading is needed.
- * If status bit is good, return 0.
- * If correctable errors occured, do that.
- * If uncorrectable errors occured, return -1.
- */
-static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat,
-		u_char *read_ecc, u_char *calc_ecc)
-{
-	int ret = -1;
-	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;
-	u_char err_type;
-	void __iomem *regs = s3c_nand.regs;
-
-	if (!dat) {
-		printk(KERN_ERR "No page data\n");
-		return ret;
-	}
-
-	if (nand_type == S3C_NAND_TYPE_SLC) {
-		/* SLC: Write ECC data to compare */
-		nfmeccdata0 = (read_ecc[1] << 16) | read_ecc[0];
-		nfmeccdata1 = (read_ecc[3] << 16) | read_ecc[2];
-		writel(nfmeccdata0, regs + S3C_NFMECCDATA0);
-		writel(nfmeccdata1, regs + S3C_NFMECCDATA1);
-
-		/* Read ECC status */
-		nfestat0 = readl(regs + S3C_NFMECCERR0);
-		err_type = nfestat0 & 0x3;
-
-		switch (err_type) {
-		case 0: /* No error */
-			ret = 0;
-			break;
-
-		case 1: /* 1 bit error (Correctable)
-			   (nfestat0 >> 7) & 0x7ff	:error byte number
-			   (nfestat0 >> 4) & 0x7	:error bit number */
-			printk(KERN_INFO "s3c-nand: 1 bit error detected at byte %ld, correcting from "
-					"0x%02x ", (nfestat0 >> 7) & 0x7ff, dat[(nfestat0 >> 7) & 0x7ff]);
-			dat[(nfestat0 >> 7) & 0x7ff] ^= (1 << ((nfestat0 >> 4) & 0x7));
-			printk("to 0x%02x...OK\n", dat[(nfestat0 >> 7) & 0x7ff]);
-			ret = 1;
-			break;
-
-		case 2: /* Multiple error */
-		case 3: /* ECC area error */
-			printk(KERN_INFO "s3c-nand: ECC uncorrectable error detected\n");
-			ret = -1;
-			break;
-		}
-	} else {
-		/* MLC: */
-		s3c_nand_wait_ecc_busy();
-
-		nfestat0 = readl(regs + S3C_NFMECCERR0);
-		nfestat1 = readl(regs + S3C_NFMECCERR1);
-		nfmlcbitpt = readl(regs + S3C_NFMLCBITPT);
-
-		err_type = (nfestat0 >> 26) & 0x7;
-
-		/* No error, If free page (all 0xff) */
-		if ((nfestat0 >> 29) & 0x1) {
-			err_type = 0;
-		} else {
-			/* No error, If all 0xff from 17th byte in oob (in case of JFFS2 format) */
-			if (dat) {
-				if (dat[17] == 0xff && dat[26] == 0xff && dat[35] == 0xff && dat[44] == 0xff && dat[54] == 0xff)
-					err_type = 0;
-			}
-		}
-
-		switch (err_type) {
-		case 5: /* Uncorrectable */
-			printk(KERN_INFO "s3c-nand: ECC uncorrectable error detected\n");
-			ret = -1;
-			break;
-
-		case 4: /* 4 bit error (Correctable) */
-			dat[(nfestat1 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 24) & 0xff);
-
-		case 3: /* 3 bit error (Correctable) */
-			dat[nfestat1 & 0x3ff] ^= ((nfmlcbitpt >> 16) & 0xff);
-
-		case 2: /* 2 bit error (Correctable) */
-			dat[(nfestat0 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 8) & 0xff);
-
-		case 1: /* 1 bit error (Correctable) */
-			printk(KERN_INFO "s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
-			dat[nfestat0 & 0x3ff] ^= (nfmlcbitpt & 0xff);
-			ret = err_type;
-			break;
-
-		case 0: /* No error */
-			ret = 0;
-			break;
-		}
-	}
-
-	return ret;
-}
-
-static int s3c_nand_write_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
-		int page)
-{
-	uint8_t *ecc_calc = chip->buffers->ecccalc;
-	int status = 0;
-	int eccbytes = chip->ecc.bytes;
-	int secc_start = mtd->oobsize - eccbytes;
-	int i;
-
-	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
-
-	/* spare area */
-	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
-	chip->write_buf(mtd, chip->oob_poi, secc_start);
-	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
-
-	for (i = 0; i < eccbytes; i++)
-		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
-
-	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
-
-	/* Send command to program the OOB data */
-	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
-
-	status = chip->waitfunc(mtd, chip);
-
-	return status & NAND_STATUS_FAIL ? -EIO : 0;
-}
-
-static int s3c_nand_read_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
-		int page, int sndcmd)
-{
-	uint8_t *ecc_calc = chip->buffers->ecccalc;
-	int eccbytes = chip->ecc.bytes;
-	int secc_start = mtd->oobsize - eccbytes;
-
-	if (sndcmd) {
-		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
-		sndcmd = 0;
-	}
-
-	chip->ecc.hwctl(mtd, NAND_ECC_READ);
-	chip->read_buf(mtd, chip->oob_poi, secc_start);
-	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
-	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
-
-	return sndcmd;
-}
-
-static void s3c_nand_write_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
-		const uint8_t *buf)
-{
-	int i, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	int secc_start = mtd->oobsize - eccbytes;
-	uint8_t *ecc_calc = chip->buffers->ecccalc;
-	const uint8_t *p = buf;
-
-	uint32_t *eccpos = chip->ecc.layout->eccpos;
-
-	/* main area */
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
-		chip->write_buf(mtd, p, eccsize);
-		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
-	}
-
-	for (i = 0; i < chip->ecc.total; i++)
-		chip->oob_poi[eccpos[i]] = ecc_calc[i];
-
-	/* spare area */
-	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
-	chip->write_buf(mtd, chip->oob_poi, secc_start);
-	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
-
-	for (i = 0; i < eccbytes; i++)
-		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
-
-	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
-}
-
-static int s3c_nand_read_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
-		uint8_t *buf, int page)
-{
-	int i, stat, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	int secc_start = mtd->oobsize - eccbytes;
-	int col = 0;
-	uint8_t *p = buf;
-	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
-	uint8_t *ecc_calc = chip->buffers->ecccalc;
-
-	col = mtd->writesize;
-	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
-
-	/* spare area */
-	chip->ecc.hwctl(mtd, NAND_ECC_READ);
-	chip->read_buf(mtd, chip->oob_poi, secc_start);
-	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
-	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
-
-	col = 0;
-
-	/* main area */
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
-		chip->ecc.hwctl(mtd, NAND_ECC_READ);
-		chip->read_buf(mtd, p, eccsize);
-		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
-
-		stat = chip->ecc.correct(mtd, p, chip->oob_poi + mecc_pos[0] +
-				((chip->ecc.steps - eccsteps) * eccbytes), 0);
-		if (stat == -1)
-			mtd->ecc_stats.failed++;
-
-		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	if(chipnr == -1)
+	{
+		/*取消选择*/
+		nand_regs->nfcont |= (1<<1);
 	}
-
-	return 0;
-}
-
-/*
- * Hardware specific page read function for MLC.
- */
-static int s3c_nand_read_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
-		uint8_t *buf, int page)
-{
-	int i, stat, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	int col = 0;
-	uint8_t *p = buf;
-	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
-
-	/* Step1: read whole oob */
-	col = mtd->writesize;
-	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
-	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
-
-	col = 0;
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
-		chip->ecc.hwctl(mtd, NAND_ECC_READ);
-		chip->read_buf(mtd, p, eccsize);
-		chip->write_buf(mtd, chip->oob_poi + mecc_pos[0] +
-				((chip->ecc.steps - eccsteps) * eccbytes), eccbytes);
-		chip->ecc.calculate(mtd, 0, 0);
-		stat = chip->ecc.correct(mtd, p, 0, 0);
-
-		if (stat == -1)
-			mtd->ecc_stats.failed++;
-
-		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	else
+	{
+		/*选中芯片*/
+		nand_regs->nfcont &= ~(1<<1);
 	}
-
-	return 0;
 }
 
-/*
- * Hardware specific page write function for MLC.
- */
-static void s3c_nand_write_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
-		const uint8_t *buf)
+static void webee_nand_cmd_ctrl(struct mtd_info *mtd, int dat,
+				unsigned int ctrl)
 {
-	int i, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	const uint8_t *p = buf;
-	uint8_t *ecc_calc = chip->buffers->ecccalc;
-	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
 
-	/* Step1: write main data and encode mecc */
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
-		chip->write_buf(mtd, p, eccsize);
-		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	if (ctrl & NAND_CLE)
+	{
+		/*发命令*/
+		nand_regs->nfcmmd = dat;
 	}
-
-	/* Step2: save encoded mecc */
-	for (i = 0; i < chip->ecc.total; i++)
-		chip->oob_poi[mecc_pos[i]] = ecc_calc[i];
-
-	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
-}
-
-
-static void s3c_nand_wait_ecc_busy_8bit(void)
-{
-	void __iomem *regs = s3c_nand.regs;
-	unsigned int timeout;
-
-	/* Wait max 100ms */
-	timeout = 1000;
-	while (readl(regs + S3C_NF8ECCERR0) & S3C_NFECCERR0_ECCBUSY) {
-		if (timeout == 0) {
-			printk(KERN_ERR "s3c_nand : wait_ecc_busy err.\n");
-			break;
-		}
-
-		timeout--;
-		udelay(100);
+	else
+	{
+		/*发地址*/
+		nand_regs->nfaddr = dat;
 	}
 }
 
-void s3c_nand_enable_hwecc_8bit(struct mtd_info *mtd, int mode)
+static int webee_nand_dev_ready(struct mtd_info *mtd)
 {
-	u_long nfcont, nfconf;
-	void __iomem *regs = s3c_nand.regs;
-
-	cur_ecc_mode = mode;
-
-	/* 8 bit selection */
-	nfconf = readl(regs + S3C_NFCONF);
-
-	nfconf &= ~(0x3 << 23);
-	nfconf |= (0x1 << 23);
-
-	writel(nfconf, (regs + S3C_NFCONF));
-
-	/* Initialize & unlock */
-	nfcont = readl(regs + S3C_NFCONT);
-	nfcont |= S3C_NFCONT_INITECC;
-	nfcont &= ~S3C_NFCONT_MECCLOCK;
-
-	if (mode == NAND_ECC_WRITE)
-		nfcont |= S3C_NFCONT_ECC_ENC;
-	else if (mode == NAND_ECC_READ)
-		nfcont &= ~S3C_NFCONT_ECC_ENC;
-
-	writel(nfcont, (regs + S3C_NFCONT));
+	/*等待命令的操作完成*/
+	return (nand_regs->nfstat & (1<<0));
 }
 
-int s3c_nand_calculate_ecc_8bit(struct mtd_info *mtd,
-		const u_char *dat, u_char *ecc_code)
+static int webee_nand_init(void)
 {
-	u_long nfcont, nfm8ecc0, nfm8ecc1, nfm8ecc2, nfm8ecc3;
-	void __iomem *regs = s3c_nand.regs;
-
-	/* Lock */
-	nfcont = readl(regs + S3C_NFCONT);
-	nfcont |= S3C_NFCONT_MECCLOCK;
-	writel(nfcont, (regs + S3C_NFCONT));
-
-	if (cur_ecc_mode == NAND_ECC_READ)
-		s3c_nand_wait_dec();
-	else {
-		s3c_nand_wait_enc();
-
-		nfm8ecc0 = readl(regs + S3C_NFM8ECC0);
-		nfm8ecc1 = readl(regs + S3C_NFM8ECC1);
-		nfm8ecc2 = readl(regs + S3C_NFM8ECC2);
-		nfm8ecc3 = readl(regs + S3C_NFM8ECC3);
-
-		ecc_code[0] = nfm8ecc0 & 0xff;
-		ecc_code[1] = (nfm8ecc0 >> 8) & 0xff;
-		ecc_code[2] = (nfm8ecc0 >> 16) & 0xff;
-		ecc_code[3] = (nfm8ecc0 >> 24) & 0xff;
-		ecc_code[4] = nfm8ecc1 & 0xff;
-		ecc_code[5] = (nfm8ecc1 >> 8) & 0xff;
-		ecc_code[6] = (nfm8ecc1 >> 16) & 0xff;
-		ecc_code[7] = (nfm8ecc1 >> 24) & 0xff;
-		ecc_code[8] = nfm8ecc2 & 0xff;
-		ecc_code[9] = (nfm8ecc2 >> 8) & 0xff;
-		ecc_code[10] = (nfm8ecc2 >> 16) & 0xff;
-		ecc_code[11] = (nfm8ecc2 >> 24) & 0xff;
-		ecc_code[12] = nfm8ecc3 & 0xff;
-	}
-
-	return 0;
-}
-
-int s3c_nand_correct_data_8bit(struct mtd_info *mtd, u_char *dat,
-		u_char *read_ecc, u_char *calc_ecc)
-{
-	int ret = -1;
-	u_long nf8eccerr0, nf8eccerr1, nf8eccerr2, nfmlc8bitpt0, nfmlc8bitpt1;
-	u_char err_type;
-	void __iomem *regs = s3c_nand.regs;
-
-	s3c_nand_wait_ecc_busy_8bit();
-
-	nf8eccerr0 = readl(regs + S3C_NF8ECCERR0);
-	nf8eccerr1 = readl(regs + S3C_NF8ECCERR1);
-	nf8eccerr2 = readl(regs + S3C_NF8ECCERR2);
-	nfmlc8bitpt0 = readl(regs + S3C_NFMLC8BITPT0);
-	nfmlc8bitpt1 = readl(regs + S3C_NFMLC8BITPT1);
-
-	err_type = (nf8eccerr0 >> 25) & 0xf;
+	/*1.分配一个nand_chip结构体*/
+	webee_nand_chip = kzalloc(sizeof(struct nand_chip),GFP_KERNEL);
+	nand_regs = ioremap(0xB0E00000,sizeof(struct nand_regs));
+	mp0_3con         = ioremap(0xE0200320,4);
+	clk_gate_ip1     = ioremap(0xE0100464,4);
+	clk_gate_block = ioremap(0xE0100480,4);
 
+	/*2.设置*/
 	/*
-	 * No error, If free page (all 0xff)
-	 * While testing, it was found that NFECCERR0[29] bit is set even if
-	 * the page contents were not zero. So this code is commented
+	 * 初始化nand_chip结构体中的函数指针
+	 * 提供选中芯片，发命令，发地址，读数据，写数据，等待等操作
 	 */
-	switch (err_type) {
-	case 9: /* Uncorrectable */
-		printk(KERN_INFO "s3c-nand: ECC uncorrectable error detected\n");
-		ret = -1;
-		break;
-
-	case 8: /* 8 bit error (Correctable) */
-		dat[(nf8eccerr2 >> 22) & 0x3ff] ^= ((nfmlc8bitpt1 >> 24) & 0xff);
-
-	case 7: /* 7 bit error (Correctable) */
-		dat[(nf8eccerr2 >> 11) & 0x3ff] ^= ((nfmlc8bitpt1 >> 16) & 0xff);
-
-	case 6: /* 6 bit error (Correctable) */
-		dat[nf8eccerr2 & 0x3ff] ^= ((nfmlc8bitpt1 >> 8) & 0xff);
-
-	case 5: /* 5 bit error (Correctable) */
-		dat[(nf8eccerr1 >> 22) & 0x3ff] ^= (nfmlc8bitpt1 & 0xff);
-
-	case 4: /* 4 bit error (Correctable) */
-		dat[(nf8eccerr1 >> 11) & 0x3ff] ^= ((nfmlc8bitpt0 >> 24) & 0xff);
-
-	case 3: /* 3 bit error (Correctable) */
-		dat[nf8eccerr1 & 0x3ff] ^= ((nfmlc8bitpt0 >> 16) & 0xff);
-
-	case 2: /* 2 bit error (Correctable) */
-		dat[(nf8eccerr0 >> 15) & 0x3ff] ^= ((nfmlc8bitpt0 >> 8) & 0xff);
-
-	case 1: /* 1 bit error (Correctable) */
-		printk(KERN_INFO "s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
-		dat[nf8eccerr0 & 0x3ff] ^= (nfmlc8bitpt0 & 0xff);
-		ret = err_type;
-		break;
-
-	case 0: /* No error */
-		ret = 0;
-		break;
-	}
-
-	return ret;
-}
-
-void s3c_nand_write_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
-		const uint8_t *buf)
-{
-	int i, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	const uint8_t *p = buf;
-	int badoffs = mtd->writesize == 512 ? NAND_SMALL_BADBLOCK_POS : NAND_LARGE_BADBLOCK_POS;
-	uint8_t *ecc_calc = chip->buffers->ecccalc;
-	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
-
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
-		chip->write_buf(mtd, p, eccsize);
-		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
-	}
-
-	chip->oob_poi[badoffs] = 0xff;
-	for (i = 0; i < chip->ecc.total; i++)
-		chip->oob_poi[mecc_pos[i]] = ecc_calc[i];
-
-	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
-}
-
-int s3c_nand_read_page_8bit(struct mtd_info *mtd, struct nand_chip *chip,
-		uint8_t *buf, int page)
-{
-	int i, stat, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	int col = 0;
-	uint8_t *p = buf;
-	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
-
-	/* Step1: read whole oob */
-	col = mtd->writesize;
-	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
-	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
-
-	col = 0;
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
-		s3c_nand_enable_hwecc_8bit(mtd, NAND_ECC_READ);
-		chip->read_buf(mtd, p, eccsize);
-		chip->write_buf(mtd, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), eccbytes);
-		chip->ecc.calculate(mtd, 0, 0);
-		stat = chip->ecc.correct(mtd, p, NULL, NULL);
-
-		if (stat == -1)
-			mtd->ecc_stats.failed++;
-
-		col = eccsize * ((mtd->writesize / eccsize) + 1 - eccsteps);
-	}
-
-	return 0;
-}
-
-int s3c_nand_read_oob_8bit(struct mtd_info *mtd, struct nand_chip *chip,
-		int page, int sndcmd)
-{
-	int eccbytes = chip->ecc.bytes;
-	int secc_start = mtd->oobsize - eccbytes;
+	webee_nand_chip->select_chip    = webee_nand_select_chip;
+	webee_nand_chip->cmd_ctrl        = webee_nand_cmd_ctrl;
+	webee_nand_chip->IO_ADDR_R   = &nand_regs->nfdata;
+	webee_nand_chip->IO_ADDR_W  = &nand_regs->nfdata;
+	webee_nand_chip->dev_ready     = webee_nand_dev_ready;
+	//webee_nand_chip->ecc.mode      = NAND_ECC_SOFT;
+	webee_nand_chip->ecc.mode      = NAND_ECC_NONE;
+	
+	/*3.硬件相关*/
+	/*使能时钟*/
+	*clk_gate_ip1     = 0xffffffff;
+	*clk_gate_block = 0xffffffff;
+
+	/* 设置相应GPIO管脚用于Nand */
+	*mp0_3con = 0x22222222;
+
+	/* 设置时序 */
+#define TWRPH1    1
+#define TWRPH0    1
+#define TACLS        1
+	nand_regs->nfconf |= (TACLS<<12) | (TWRPH0<<8) | (TWRPH1<<4);
 
-	if (sndcmd) {
-		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
-		sndcmd = 0;
-	}
-
-	chip->read_buf(mtd, chip->oob_poi, secc_start);
-	return sndcmd;
-}
-
-int s3c_nand_write_oob_8bit(struct mtd_info *mtd, struct nand_chip *chip, int page)
-{
-	int status = 0;
-	int eccbytes = chip->ecc.bytes;
-	int secc_start = mtd->oobsize - eccbytes;
-
-	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
-
-	chip->write_buf(mtd, chip->oob_poi, secc_start);
-	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
-	status = chip->waitfunc(mtd, chip);
-
-	return status & NAND_STATUS_FAIL ? -EIO : 0;
-}
-#endif
-
-
-/* s3c_nand_probe
- *
- * called by device layer when it finds a device matching
- * one our driver can handled. This code checks to see if
- * it can allocate all necessary resources then calls the
- * nand layer to look for devices
- */
-static int s3c_nand_probe(struct platform_device *pdev, enum s3c_cpu_type cpu_type)
-{
-#if defined(CONFIG_ARCH_S5PV210)
-	struct s3c_nand_mtd_info *plat_info = &s3c_nand_mtd_part_info;
-#else
-	struct s3c_nand_mtd_info *plat_info = pdev->dev.platform_data;
-#endif
-	struct mtd_partition *partition_info = (struct mtd_partition *)plat_info->partition;
-	struct nand_chip *nand;
-	struct resource *res;
-	int err = 0;
-	int ret = 0;
-	int i, size;
-#ifdef CONFIG_MTD_PARTITIONS
-	struct mtd_partition *partitions = NULL;
-	int num_partitions = 0;
-#endif
-
-#if defined(CONFIG_MTD_NAND_S3C_HWECC)
-	struct nand_flash_dev *type = NULL;
-	u_char tmp;
-	int j;
-#endif
-
-	/* get the clock source and enable it */
-	s3c_nand.clk = clk_get(&pdev->dev, "nand");
-	if (IS_ERR(s3c_nand.clk)) {
-		dev_err(&pdev->dev, "failed to get clock");
-		err = -ENOENT;
-		goto exit_error;
-	}
-
-	clk_enable(s3c_nand.clk);
-
-	/* allocate and map the resource */
-
-	/* currently we assume we have the one resource */
-	res  = pdev->resource;
-	size = res->end - res->start + 1;
-
-	s3c_nand.area = request_mem_region(res->start, size, pdev->name);
-
-	if (s3c_nand.area == NULL) {
-		dev_err(&pdev->dev, "cannot reserve register region\n");
-		err = -ENOENT;
-		goto exit_error;
-	}
-
-	s3c_nand.cpu_type   = cpu_type;
-	s3c_nand.device     = &pdev->dev;
-	s3c_nand.regs       = ioremap(res->start, size);
-
-	if (s3c_nand.regs == NULL) {
-		dev_err(&pdev->dev, "cannot reserve register region\n");
-		err = -EIO;
-		goto exit_error;
-	}
-
-	/* allocate memory for MTD device structure and private data */
-	s3c_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);
-
-	if (!s3c_mtd) {
-		printk(KERN_ERR "Unable to allocate NAND MTD dev structure.\n");
-		return -ENOMEM;
-	}
-
-	/* Get pointer to private data */
-	nand = (struct nand_chip *) (&s3c_mtd[1]);
-
-	/* Initialize structures */
-	memset((char *) s3c_mtd, 0, sizeof(struct mtd_info));
-	memset((char *) nand, 0, sizeof(struct nand_chip));
-
-	/* Link the private data with the MTD structure */
-	s3c_mtd->priv = nand;
-
-	for (i = 0; i < plat_info->chip_nr; i++) {
-		nand->IO_ADDR_R		= (char *)(s3c_nand.regs + S3C_NFDATA);
-		nand->IO_ADDR_W		= (char *)(s3c_nand.regs + S3C_NFDATA);
-		nand->cmd_ctrl		= s3c_nand_hwcontrol;
-		nand->dev_ready		= s3c_nand_device_ready;
-		nand->scan_bbt		= s3c_nand_scan_bbt;
-		nand->options		= 0;
-		nand->badblockbits	= 8;
-
-
-#if defined(CONFIG_MTD_NAND_S3C_HWECC)
-		nand->ecc.mode		= NAND_ECC_HW;
-		nand->ecc.hwctl		= s3c_nand_enable_hwecc;
-		nand->ecc.calculate	= s3c_nand_calculate_ecc;
-		nand->ecc.correct	= s3c_nand_correct_data;
-
-		s3c_nand_hwcontrol(0, NAND_CMD_READID, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
-		s3c_nand_hwcontrol(0, 0x00, NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE);
-		s3c_nand_hwcontrol(0, 0x00, NAND_NCE | NAND_ALE);
-		s3c_nand_hwcontrol(0, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
-		s3c_nand_device_ready(0);
-
-		tmp = readb(nand->IO_ADDR_R); /* Maf. ID */
-		tmp = readb(nand->IO_ADDR_R); /* Device ID */
-
-		for (j = 0; nand_flash_ids[j].name != NULL; j++) {
-			if (tmp == nand_flash_ids[j].id) {
-				type = &nand_flash_ids[j];
-				break;
-			}
-		}
-
-		if (!type) {
-			printk(KERN_ERR "Unknown NAND Device.\n");
-			goto exit_error;
-		}
-
-		nand->cellinfo = readb(nand->IO_ADDR_R);	/* the 3rd byte */
-		tmp = readb(nand->IO_ADDR_R);			/* the 4th byte */
-		if (!type->pagesize) {
-			if (((nand->cellinfo >> 2) & 0x3) == 0) {
-				nand_type = S3C_NAND_TYPE_SLC;
-				nand->ecc.size = 512;
-				nand->ecc.bytes	= 4;
-
-				/*  For 4KB Page 8_bit ECC */
-				if ((1024 << (tmp & 3)) == 4096) {
-					/* Page size is 4Kbytes */
-					nand->ecc.read_page = s3c_nand_read_page_8bit;
-					nand->ecc.write_page = s3c_nand_write_page_8bit;
-					nand->ecc.read_oob = s3c_nand_read_oob_8bit;
-					nand->ecc.write_oob = s3c_nand_write_oob_8bit;
-					nand->ecc.layout = &s3c_nand_oob_128;
-					nand->ecc.hwctl = s3c_nand_enable_hwecc_8bit;
-					nand->ecc.calculate = s3c_nand_calculate_ecc_8bit;
-					nand->ecc.correct = s3c_nand_correct_data_8bit;
-					nand->ecc.size = 512;
-					nand->ecc.bytes = 13;
-					nand->options |= NAND_NO_SUBPAGE_WRITE;
-				} else {
-					if ((1024 << (tmp & 0x3)) > 512) {
-						nand->ecc.read_page = s3c_nand_read_page_1bit;
-						nand->ecc.write_page = s3c_nand_write_page_1bit;
-						nand->ecc.read_oob = s3c_nand_read_oob_1bit;
-						nand->ecc.write_oob = s3c_nand_write_oob_1bit;
-						nand->ecc.layout = &s3c_nand_oob_64;
-					} else {
-						nand->ecc.layout = &s3c_nand_oob_16;
-					}
-				}
-			} else {
-				nand_type = S3C_NAND_TYPE_MLC;
-				nand->options |= NAND_NO_SUBPAGE_WRITE;	/* NOP = 1 if MLC */
-
-				if ((1024 << (tmp & 3)) == 4096) {
-					/* Page size is 4Kbytes */
-					nand->ecc.read_page = s3c_nand_read_page_8bit;
-					nand->ecc.write_page = s3c_nand_write_page_8bit;
-					nand->ecc.read_oob = s3c_nand_read_oob_8bit;
-					nand->ecc.write_oob = s3c_nand_write_oob_8bit;
-					nand->ecc.layout = &s3c_nand_oob_128;
-					nand->ecc.hwctl = s3c_nand_enable_hwecc_8bit;
-					nand->ecc.calculate = s3c_nand_calculate_ecc_8bit;
-					nand->ecc.correct = s3c_nand_correct_data_8bit;
-					nand->ecc.size = 512;
-					nand->ecc.bytes = 13;
-					nand->options |= NAND_NO_SUBPAGE_WRITE;
-				} else {
-					nand->ecc.read_page = s3c_nand_read_page_4bit;
-					nand->ecc.write_page = s3c_nand_write_page_4bit;
-					nand->ecc.size = 512;
-					nand->ecc.bytes = 8;    /* really 7 bytes */
-					nand->ecc.layout = &s3c_nand_oob_mlc_64;
-				}
-			}
-		} else {
-			nand_type = S3C_NAND_TYPE_SLC;
-			nand->ecc.size = 512;
-			nand->cellinfo = 0;
-			nand->ecc.bytes = 4;
-			nand->ecc.layout = &s3c_nand_oob_16;
-		}
-
-		printk(KERN_INFO "S3C NAND Driver is using hardware ECC.\n");
-#else
-		nand->ecc.mode = NAND_ECC_SOFT;
-		printk(KERN_INFO "S3C NAND Driver is using software ECC.\n");
-#endif
-		if (nand_scan(s3c_mtd, 1)) {
-			ret = -ENXIO;
-			goto exit_error;
-		}
-
-		/* Got the page size now, let's config it for proper access */
-		s3c_nand_init_later(s3c_mtd);
-
-		s3c_mtd->name = dev_name(&pdev->dev);
-		s3c_mtd->owner = THIS_MODULE;
-
-		/* Register the partitions */
-#ifdef CONFIG_MTD_CMDLINE_PARTS
-		num_partitions = parse_mtd_partitions(s3c_mtd, part_probes, &partitions, 0);
-#endif
-		if (num_partitions <= 0) {
-			/* default partition table */
-			num_partitions = plat_info->mtd_part_nr;
-			partitions = partition_info;
-		}
-
-		add_mtd_partitions(s3c_mtd, partitions, num_partitions);
-	}
-
-	pr_debug("initialized ok\n");
-	return 0;
-
-exit_error:
-	kfree(s3c_mtd);
-
-	return ret;
-}
-
-static int s5pv210_nand_probe(struct platform_device *dev)
-{
-	return s3c_nand_probe(dev, TYPE_S5PV210);
-}
-
-/* PM Support */
-#if defined(CONFIG_PM)
-static u_long nfconf_save, nfcont_save;
-
-static int s3c_nand_suspend(struct platform_device *dev, pm_message_t pm)
-{
-	void __iomem *regs = s3c_nand.regs;
-
-	nfconf_save = readl(regs + S3C_NFCONF);
-	nfcont_save = readl(regs + S3C_NFCONT);
-
-	clk_disable(s3c_nand.clk);
-
-	printk("s3c_nand: suspend\n");
-	return 0;
-}
-
-static int s3c_nand_resume(struct platform_device *dev)
-{
-	void __iomem *regs = s3c_nand.regs;
-
-	clk_enable(s3c_nand.clk);
-	udelay(5);
-
-	writel(nfconf_save, regs + S3C_NFCONF);
-	writel(nfcont_save, regs + S3C_NFCONT);
+	/*
+	 * AddrCycle[1]:1 = 发送地址需要5个周期
+	 */
+	nand_regs->nfconf |= 1<<1;
 
-	printk("s3c_nand: resume\n");
-	return 0;
-}
+	/*
+	 * MODE[0]:1     = 使能Nand Flash控制器
+	 * Reg_nCE0[1]:1 = 取消片选
+	 */
+	nand_regs->nfcont |= (1<<1)|(1<<0);
+		
+	/*4.使用*/
+	webee_nand_mtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);
+	webee_nand_mtd->owner = THIS_MODULE;
+	webee_nand_mtd->priv = webee_nand_chip;
 
-#else
-#define s3c_nand_suspend NULL
-#define s3c_nand_resume NULL
-#endif
+	nand_scan(webee_nand_mtd, 1);
 
-/* device management functions */
-static int s3c_nand_remove(struct platform_device *dev)
-{
-	platform_set_drvdata(dev, NULL);
+	/*5.添加分区*/
+	add_mtd_partitions(webee_nand_mtd, webee_nand_part, 3);
 
 	return 0;
 }
 
-static struct platform_driver s5pv210_nand_driver = {
-	.probe          = s5pv210_nand_probe,
-	.remove         = s3c_nand_remove,
-	.suspend        = s3c_nand_suspend,
-	.resume         = s3c_nand_resume,
-	.driver         = {
-		.name   = "s5pv210-nand",
-		.owner  = THIS_MODULE,
-	},
-};
-
-static int __init s3c_nand_init(void)
-{
-	printk(KERN_INFO "S3C NAND Driver, (c) 2008 Samsung Electronics\n");
-
-	return platform_driver_register(&s5pv210_nand_driver);
-}
-
-static void __exit s3c_nand_exit(void)
+static void webee_nand_exit(void)
 {
-	platform_driver_unregister(&s5pv210_nand_driver);
+	kfree(webee_nand_mtd);
+	iounmap(nand_regs);
+	kfree(webee_nand_chip);
 }
 
-module_init(s3c_nand_init);
-module_exit(s3c_nand_exit);
+module_init(webee_nand_init);
+module_exit(webee_nand_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Jinsung Yang <jsgood.yang@samsung.com>");
-MODULE_DESCRIPTION("S3C MTD NAND driver");
 
-- 
1.7.9.5

